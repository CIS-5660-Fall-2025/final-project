// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CopyFromTexture
#pragma kernel Upsample2x
#pragma kernel FlowRouting
#pragma kernel ErosionStep
#pragma kernel ThermalStep
#pragma kernel DepositStep
#pragma kernel Retargeting
#pragma kernel Breaching

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
uniform float _CellSize = 1.0;
uniform uint _Width;
uniform uint _Height;

uniform float _DepositionStrength = 1.0;
uniform float _RainIntensity = 2.6;

Texture2D<float> _InHeightTex;
Texture2D<float> _InHeightRT;
RWTexture2D<float> _OutHeightRT;
RWTexture2D<float> _StreamRT;
RWTexture2D<float> _TempRT;
RWTexture2D<float> _SedimentRT;
Texture2D<float> _OrigHeightRT;

static const int2 next8[8] =
{
    int2(0, 1), int2(1, 1), int2(1, 0), int2(1, -1),
    int2(0, -1), int2(-1, -1), int2(-1, 0), int2(-1, 1)
};

uniform float _FlowP = 1.3;
uniform float _ErosionK = 0.0005;
uniform float _ErosionPSA = 0.8;
uniform float _ErosionPSL = 2.0;
uniform float _ErosionDT = 1.0;
uniform float _MaxStreamPower = 10000.0;

static const float orthoDist = 1.0;
static const float diagonalDist = 1.4142;

// Thermal
uniform float _Talus = 30.0;
uniform float _ThermalDT = 1.0;

[numthreads(8, 8, 1)]
void CopyFromTexture(uint3 id : SV_DispatchThreadID)
{
    uint2 uv = id.xy;
    float h = _InHeightTex.Load(int3(uv, 0));
    _OutHeightRT[uv] = h;
}

float CubicCatmullRom(float A, float B, float C, float D, float t)
{
    float a0 = -0.5 * A + 1.5 * B - 1.5 * C + 0.5 * D;
    float a1 = 1.0 * A - 2.5 * B + 2.0 * C - 0.5 * D;
    float a2 = -0.5 * A + 0.5 * C;
    float a3 = B;

    return ((a0 * t + a1) * t + a2) * t + a3;
}

float SampleHeightClamped(int x, int y, uint w, uint h)
{
    x = clamp(x, 0, (int) w - 1);
    y = clamp(y, 0, (int) h - 1);
    return _InHeightRT.Load(int3(x, y, 0));
}

[numthreads(8, 8, 1)]
void Upsample2x(uint3 id : SV_DispatchThreadID)
{
    uint2 dstXY = id.xy;
    
    uint dstW, dstH;
    _OutHeightRT.GetDimensions(dstW, dstH);
    if (dstXY.x >= dstW || dstXY.y >= dstH)
        return;
    
    uint srcW, srcH;
    _InHeightRT.GetDimensions(srcW, srcH);

    float2 srcSize = float2(srcW, srcH);
    float2 dstSize = float2(dstW, dstH);
    float2 dstIdx = float2(dstXY);
    
    float2 srcIdx = dstIdx * (srcSize - 1.0) / (dstSize - 1.0);

    float2 srcFloor = floor(srcIdx);
    float2 t = srcIdx - srcFloor; 

    int ix = (int) srcFloor.x;
    int iy = (int) srcFloor.y;
    
    float rowVal[4];

    for (int j = -1; j <= 2; ++j)
    {
        int y = iy + j;

        float v0 = SampleHeightClamped(ix - 1, y, srcW, srcH);
        float v1 = SampleHeightClamped(ix, y, srcW, srcH);
        float v2 = SampleHeightClamped(ix + 1, y, srcW, srcH);
        float v3 = SampleHeightClamped(ix + 2, y, srcW, srcH);

        rowVal[j + 1] = CubicCatmullRom(v0, v1, v2, v3, t.x);
    }
    
    float h = CubicCatmullRom(rowVal[0], rowVal[1], rowVal[2], rowVal[3], t.y);

    _OutHeightRT[dstXY] = h;
}

bool IsInBounds(int2 p)
{
    return p.x >= 0 && p.x < (int) _Width && p.y >= 0 && p.y < (int) _Height;
}

float GetSediment(int2 p)
{
    if (!IsInBounds(p))
        return 0.0;
    return _SedimentRT[p];
}

int2 GetClampedCoord(int2 p)
{
    p.x = clamp(p.x, 0, (int) _Width - 1);
    p.y = clamp(p.y, 0, (int) _Height - 1);
    return p;
}

float GetDistance(int2 a, int2 b)
{
    int2 delta = a - b;
    if (delta.x == 0 || delta.y == 0)
        return orthoDist;
    return diagonalDist;
}

float GetHeight(int2 p)
{
    p = GetClampedCoord(p);
    return _InHeightRT[p];
}

float GetSlope(int2 p, int2 q)
{
    if (!IsInBounds(p) || !IsInBounds(q))
        return 0.0;
    if (p.x == q.x && p.y == q.y)
        return 0.0;
    
    float dh = GetHeight(q) - GetHeight(p);
    float dist = GetDistance(p, q);
    return dh / dist;
}

void GetFlowWeights(int2 p, out float weights[8])
{
    float slopeSum = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        float slope = GetSlope(p + next8[i], p);
        if (slope > 0.0)
        {
            weights[i] = pow(abs(slope), _FlowP);
            slopeSum += weights[i];
        }
        else
        {
            weights[i] = 0.0;
        }
    }
    
    slopeSum = (slopeSum < 0.00001) ? 1.0 : slopeSum;
    for (int i = 0; i < 8; i++)
        weights[i] /= slopeSum;
}

float GetStream(int2 p)
{
    if (!IsInBounds(p))
        return 0.0;
    return _StreamRT[p];
}

float ComputeIncomingFlow(int2 p)
{
    float totalFlow = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 q = p + next8[i];
        if (!IsInBounds(q))
            continue;
        
        float weights[8];
        GetFlowWeights(q, weights);
        
        int oppositeDir = (i + 4) % 8;
        if (weights[oppositeDir] > 0.0)
        {
            totalFlow += weights[oppositeDir] * GetStream(q);
        }
    }
    
    return totalFlow;
}


[numthreads(8, 8, 1)]
void FlowRouting(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float cellArea = _CellSize * _CellSize;
    float stream = cellArea * _RainIntensity;
    
    stream += ComputeIncomingFlow(pos);
    
    _StreamRT[pos] = stream;
}

int2 GetSteepestNeighbor(int2 p)
{
    int2 steepest = int2(0, 0);
    float maxSlope = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = p + next8[i];
        float slope = GetSlope(neighbor, p);
        if (slope > maxSlope)
        {
            maxSlope = slope;
            steepest = next8[i];
        }
    }
    return steepest;
}

[numthreads(8, 8, 1)]
void ErosionStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float currentHeight = GetHeight(pos);
    float stream = GetStream(pos);
    
    int2 dir = GetSteepestNeighbor(pos);
    int2 receiver = pos + dir;
    
    if (!IsInBounds(receiver))
        return;
    
    float receiverHeight = GetHeight(receiver);
    float steepestSlope = GetSlope(receiver, pos);
    
    if (steepestSlope <= 0.0)
        return;
    
    float streamPower = pow(stream, _ErosionPSA) * pow(steepestSlope, _ErosionPSL);
    streamPower = clamp(streamPower, 0.0, _MaxStreamPower);
    streamPower *= _ErosionK;
    
    float newHeight = currentHeight - _ErosionDT * streamPower;
    newHeight = max(newHeight, receiverHeight);
    
    _OutHeightRT[pos] = newHeight;
}

[numthreads(8, 8, 1)]
void ThermalStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float talus_rad = radians(_Talus);
    float tan_talus = tan(talus_rad);
    
    float height = GetHeight(pos);
    float totalChange = 0.0;
    int activeCount = 0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = pos + next8[i];
        if (!IsInBounds(neighbor))
            continue;
        
        float neighborHeight = GetHeight(neighbor);
        float slope = GetSlope(neighbor, pos);
        
        if (slope > tan_talus)
        {
            float dist = GetDistance(pos, neighbor);
            float targetHeight = neighborHeight + tan_talus * dist;
            totalChange += (targetHeight - height);
            activeCount++;
        }
    }
    
    if (activeCount > 0)
    {
        float avgChange = totalChange / (float) activeCount;
        height += _ThermalDT * avgChange * 0.1;
    }
    
    _TempRT[pos] = height;
}

[numthreads(8, 8, 1)]
void DepositStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float height = GetHeight(pos);
    float stream = GetStream(pos);
    float sediment = GetSediment(pos);
    
    float incomingSediment = 0.0;
    for (int i = 0; i < 8; i++)
    {
        int2 q = pos + next8[i];
        if (!IsInBounds(q))
            continue;
        
        float weights[8];
        GetFlowWeights(q, weights);
        int oppositeDir = (i + 4) % 8;
        if (weights[oppositeDir] > 0.0)
        {
            incomingSediment += weights[oppositeDir] * GetSediment(q);
        }
    }
    
    sediment += incomingSediment;
    
    int2 dir = GetSteepestNeighbor(pos);
    int2 receiver = pos + dir;
    float steepestSlope = IsInBounds(receiver) ? GetSlope(receiver, pos) : 0.0;
    
    float speed = clamp(pow(steepestSlope, 2.0), 0.0, 1.0);
    float streamCapacity = pow(stream, 0.3) * speed;
    
    if (_DepositionStrength * sediment > streamCapacity)
    {
        float depositAmount = min(sediment, (_DepositionStrength * sediment - streamCapacity) * 0.1);
        height += depositAmount;
        sediment = max(0.0, sediment - depositAmount);
    }
    
    sediment += 0.1 * streamCapacity;
    
    _OutHeightRT[pos] = height;
    _SedimentRT[pos] = sediment;
}


float _A0; // drainage threshold to pick constraints (ridges/peaks)
int _RetargetIters; // e.g., 200-500 (paper uses ~500)
float _DiffusionLambda; // e.g., 0.25 (stable for 4-neighbor laplacian)


static const int2 N4[4] = { int2(1, 0), int2(-1, 0), int2(0, 1), int2(0, -1) };



[numthreads(8, 8, 1)]
void Retargeting(uint3 id : SV_DispatchThreadID)
{
    const int2 p = int2(id.xy);
    if (!IsInBounds(p))
        return;

    // 1) Build constraint mask m(p) and target error δ(p) = h0 - hA at those points.
    const float hA = _InHeightRT[p];
    const float h0 = _OrigHeightRT[p];
    const float a = _StreamRT[p];

    const bool isConstraint = (a < _A0); // ridge/peak proxy
    const float delta = h0 - hA; // δ(p)
    
    // 2) Jacobi diffusion of the error field E with pinned constraints:
    //    E_{t+1}(p) = m*δ + (1-m) * ( E_t(p) + λ * (Σ_nb E_t(nb) - 4*E_t(p)) )
    // We do it locally by keeping two rolling scalars: Et and EtNext.
    // (A full ping-pong texture isn’t necessary since the update is per-pixel; we approximate
    //  Jacobi by lagging neighbor reads using Et from previous sub-iteration kept in registers.)
    float Et = isConstraint ? delta : 0.0;

    // Do a small gather of neighbors every iteration. To avoid diverging, clamp λ <= 0.25.
    [loop]
    for (int it = 0; it < _RetargetIters; ++it)
    {
        if (isConstraint)
        {
            Et = delta;
            continue;
        }

        float lap = 0.0;
        float center = Et;
        // Read neighbors' Et from last sub-iteration by re-sampling current values.
        // To keep it consistent per iteration without extra textures, we approximate by
        // recomputing neighbors' Et using the same rule but single substep lag:
        float sumN = 0.0;
        int countN = 0;
        [unroll]
        for (int k = 0; k < 4; ++k)
        {
            int2 q = p + N4[k];
            if (!IsInBounds(q))
                continue;

            // Neighbor constraint & neighbor delta
            const float aN = _StreamRT[q];
            const bool mN = (aN < _A0);
            const float hAN = _InHeightRT[q];
            const float h0N = _OrigHeightRT[q];
            const float dN = h0N - hAN;

            // Neighbor's Et (pinned if constraint)
            float EtN = mN ? dN : Et; // lagged approximation; good in practice for many iters
            sumN += EtN;
            countN++;
        }
        if (countN > 0)
        {
            lap = (sumN - countN * center); // discrete 4-neigh Laplacian (no division by h^2 since we just need smooth)
        }

        float EtNext = center + _DiffusionLambda * lap;
        Et = EtNext;
    }

    // 3) Apply correction: h_R = h_A + E
    _TempRT[p] = hA + Et;
}

// Parameters
int _BreachIters; // small number (e.g., 8-16) for inner fast pit-fill relaxation
float _CarveEps; // small epsilon (e.g., 1e-3f)
int _Radius; // current partial scale radius r  (e.g., 8, 4, 2, 1)
int _BlurPass; // 0 = horizontal blur, 1 = vertical blur, 2 = apply (see below)

SamplerState sampLinearClamp
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};



[numthreads(8, 8, 1)]
void Breaching(uint3 id : SV_DispatchThreadID)
{
    int2 p = int2(id.xy);
    if (!IsInBounds(p))
        return;

    // --- Step A: Fast approximate full-breach proxy B(T) via local pit-filling relaxation ---
    // Initialize with current height
    float h = _InHeightRT[p];
    float hFill = h;

    // Jacobi-style "raise-to-spill" (pit-fill). This *fills* pits; we'll turn that into a carve signal.
    // Few iterations are enough to capture local basins for our multi-scale strategy.
    [loop]
    for (int it = 0; it < _BreachIters; ++it)
    {
        float minNbr = 1e30;
        [unroll]
        for (int k = 0; k < 8; ++k)
        {
            int2 q = p + next8[k];
            if (!IsInBounds(q))
                continue;
            float hq = _InHeightRT[q]; // neighbor height reference
            // Spill elevation along the edge toward a neighbor cannot be lower than neighbor
            minNbr = min(minNbr, hq);
        }
        // If closed lower than all neighbors, raise toward minNbr; otherwise unchanged.
        // Smooth step: hFill <- max(hFill, minNbr - eps), accumulated over a few iterations.
        float target = minNbr - _CarveEps;
        if (hFill < target)
            hFill = target;
    }

    // B(T) proxy: the pit-filled surface
    float hB = hFill;

    // --- Step B: Δ = T - B(T) >= 0 where carving is needed
    float delta = max(0.0, h - hB);

    // We now run a *separable blur* of delta with radius = _Radius,
    // using two dispatches from C#: first _BlurPass=0 (horiz), then _BlurPass=1 (vert),
    // then _BlurPass=2 (apply subtraction).
    if (_BlurPass == 0)
    {
        // Horizontal box blur of Δ into _TempRT
        int r = _Radius;
        float sum = 0.0;
        int cnt = 0;
        [loop]
        for (int dx = -r; dx <= r; ++dx)
        {
            int2 q = p + int2(dx, 0);
            if (!IsInBounds(q))
                continue;

            // recompute delta at q (cheap; avoids extra textures)
            float hq = _InHeightRT[q];
            float hFq = hq;
            [unroll]
            for (int it = 0; it < 2; ++it) // tiny pit-fill taps for neighbors, keeps it fast
            {
                float mn = 1e30;
                [unroll]
                for (int k = 0; k < 8; ++k)
                {
                    int2 t = q + next8[k];
                    if (!IsInBounds(t))
                        continue;
                    mn = min(mn, _InHeightRT[t]);
                }
                float tgt = mn - _CarveEps;
                if (hFq < tgt)
                    hFq = tgt;
            }
            float d = max(0.0, hq - hFq);
            sum += d;
            cnt++;
        }
        _TempRT[p] = (cnt > 0) ? (sum / cnt) : delta;
        return;
    }
    else if (_BlurPass == 1)
    {
        // Vertical box blur: read the horizontal-blurred Δ from _TempRT, write back
        int r = _Radius;
        float sum = 0.0;
        int cnt = 0;
        [loop]
        for (int dy = -r; dy <= r; ++dy)
        {
            int2 q = p + int2(0, dy);
            if (!IsInBounds(q))
                continue;
            sum += _TempRT[q];
            cnt++;
        }
        _TempRT[p] = (cnt > 0) ? (sum / cnt) : _TempRT[p];
        return;
    }
    else // _BlurPass == 2
    {
        // Final apply: T' = T - Δ_blurred (partial breach at this scale)
        float dBlur = _TempRT[p];
        _TempRT[p] = h - dBlur;
        return;
    }
}