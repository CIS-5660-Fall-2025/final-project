// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CopyFromTexture
#pragma kernel Upsample2x
#pragma kernel FlowRouting
#pragma kernel ErosionStep
#pragma kernel ThermalStep
#pragma kernel DepositStep
#pragma kernel Retargeting
#pragma kernel Breaching

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
uniform float _CellSize = 1.0;
uniform uint _Width;
uniform uint _Height;

uniform float _DepositionStrength = 1.0;
uniform float _RainIntensity = 2.6;

Texture2D<float> _InHeightTex;
Texture2D<float> _InHeightRT;
RWTexture2D<float> _OutHeightRT;
RWTexture2D<float> _StreamRT;
RWTexture2D<float> _TempRT;
RWTexture2D<float> _SedimentRT;

static const int2 next8[8] =
{
    int2(0, 1), int2(1, 1), int2(1, 0), int2(1, -1),
    int2(0, -1), int2(-1, -1), int2(-1, 0), int2(-1, 1)
};

uniform float _FlowP = 1.3;
uniform float _ErosionK = 0.0005;
uniform float _ErosionPSA = 0.8;
uniform float _ErosionPSL = 2.0;
uniform float _ErosionDT = 1.0;
uniform float _MaxStreamPower = 10000.0;

static const float orthoDist = 1.0;
static const float diagonalDist = 1.4142;

// Thermal
uniform float _Talus = 30.0;
uniform float _ThermalDT = 1.0;

[numthreads(8, 8, 1)]
void CopyFromTexture(uint3 id : SV_DispatchThreadID)
{
    uint2 uv = id.xy;
    float h = _InHeightTex.Load(int3(uv, 0));
    _OutHeightRT[uv] = h;
}

float CubicCatmullRom(float A, float B, float C, float D, float t)
{
    float a0 = -0.5 * A + 1.5 * B - 1.5 * C + 0.5 * D;
    float a1 = 1.0 * A - 2.5 * B + 2.0 * C - 0.5 * D;
    float a2 = -0.5 * A + 0.5 * C;
    float a3 = B;

    return ((a0 * t + a1) * t + a2) * t + a3;
}

float SampleHeightClamped(int x, int y, uint w, uint h)
{
    x = clamp(x, 0, (int) w - 1);
    y = clamp(y, 0, (int) h - 1);
    return _InHeightRT.Load(int3(x, y, 0));
}

[numthreads(8, 8, 1)]
void Upsample2x(uint3 id : SV_DispatchThreadID)
{
    uint2 dstXY = id.xy;
    
    uint dstW, dstH;
    _OutHeightRT.GetDimensions(dstW, dstH);
    if (dstXY.x >= dstW || dstXY.y >= dstH)
        return;
    
    uint srcW, srcH;
    _InHeightRT.GetDimensions(srcW, srcH);

    float2 srcSize = float2(srcW, srcH);
    float2 dstSize = float2(dstW, dstH);
    float2 dstIdx = float2(dstXY);
    
    float2 srcIdx = dstIdx * (srcSize - 1.0) / (dstSize - 1.0);

    float2 srcFloor = floor(srcIdx);
    float2 t = srcIdx - srcFloor; 

    int ix = (int) srcFloor.x;
    int iy = (int) srcFloor.y;
    
    float rowVal[4];

    for (int j = -1; j <= 2; ++j)
    {
        int y = iy + j;

        float v0 = SampleHeightClamped(ix - 1, y, srcW, srcH);
        float v1 = SampleHeightClamped(ix, y, srcW, srcH);
        float v2 = SampleHeightClamped(ix + 1, y, srcW, srcH);
        float v3 = SampleHeightClamped(ix + 2, y, srcW, srcH);

        rowVal[j + 1] = CubicCatmullRom(v0, v1, v2, v3, t.x);
    }
    
    float h = CubicCatmullRom(rowVal[0], rowVal[1], rowVal[2], rowVal[3], t.y);

    _OutHeightRT[dstXY] = h;
}

bool IsInBounds(int2 p)
{
    return p.x >= 0 && p.x < (int) _Width && p.y >= 0 && p.y < (int) _Height;
}

float GetSediment(int2 p)
{
    if (!IsInBounds(p))
        return 0.0;
    return _SedimentRT[p];
}

int2 GetClampedCoord(int2 p)
{
    p.x = clamp(p.x, 0, (int) _Width - 1);
    p.y = clamp(p.y, 0, (int) _Height - 1);
    return p;
}

float GetDistance(int2 a, int2 b)
{
    int2 delta = a - b;
    if (delta.x == 0 || delta.y == 0)
        return orthoDist;
    return diagonalDist;
}

float GetHeight(int2 p)
{
    p = GetClampedCoord(p);
    return _InHeightRT[p];
}

float GetSlope(int2 p, int2 q)
{
    if (!IsInBounds(p) || !IsInBounds(q))
        return 0.0;
    if (p.x == q.x && p.y == q.y)
        return 0.0;
    
    float dh = GetHeight(q) - GetHeight(p);
    float dist = GetDistance(p, q);
    return dh / dist;
}

void GetFlowWeights(int2 p, out float weights[8])
{
    float slopeSum = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        float slope = GetSlope(p + next8[i], p);
        if (slope > 0.0)
        {
            weights[i] = pow(abs(slope), _FlowP);
            slopeSum += weights[i];
        }
        else
        {
            weights[i] = 0.0;
        }
    }
    
    slopeSum = (slopeSum < 0.00001) ? 1.0 : slopeSum;
    for (int i = 0; i < 8; i++)
        weights[i] /= slopeSum;
}

float GetStream(int2 p)
{
    if (!IsInBounds(p))
        return 0.0;
    return _StreamRT[p];
}

float ComputeIncomingFlow(int2 p)
{
    float totalFlow = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 q = p + next8[i];
        if (!IsInBounds(q))
            continue;
        
        float weights[8];
        GetFlowWeights(q, weights);
        
        int oppositeDir = (i + 4) % 8;
        if (weights[oppositeDir] > 0.0)
        {
            totalFlow += weights[oppositeDir] * GetStream(q);
        }
    }
    
    return totalFlow;
}


[numthreads(8, 8, 1)]
void FlowRouting(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float cellArea = _CellSize * _CellSize;
    float stream = cellArea * _RainIntensity;
    
    stream += ComputeIncomingFlow(pos);
    
    _StreamRT[pos] = stream;
}

int2 GetSteepestNeighbor(int2 p)
{
    int2 steepest = int2(0, 0);
    float maxSlope = 0.0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = p + next8[i];
        float slope = GetSlope(neighbor, p);
        if (slope > maxSlope)
        {
            maxSlope = slope;
            steepest = next8[i];
        }
    }
    return steepest;
}

[numthreads(8, 8, 1)]
void ErosionStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float currentHeight = GetHeight(pos);
    float stream = GetStream(pos);
    
    int2 dir = GetSteepestNeighbor(pos);
    int2 receiver = pos + dir;
    
    if (!IsInBounds(receiver))
        return;
    
    float receiverHeight = GetHeight(receiver);
    float steepestSlope = GetSlope(receiver, pos);
    
    if (steepestSlope <= 0.0)
        return;
    
    float streamPower = pow(stream, _ErosionPSA) * pow(steepestSlope, _ErosionPSL);
    streamPower = clamp(streamPower, 0.0, _MaxStreamPower);
    streamPower *= _ErosionK;
    
    float newHeight = currentHeight - _ErosionDT * streamPower;
    newHeight = max(newHeight, receiverHeight);
    
    _OutHeightRT[pos] = newHeight;
}

[numthreads(8, 8, 1)]
void ThermalStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float talus_rad = radians(_Talus);
    float tan_talus = tan(talus_rad);
    
    float height = GetHeight(pos);
    float totalChange = 0.0;
    int activeCount = 0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = pos + next8[i];
        if (!IsInBounds(neighbor))
            continue;
        
        float neighborHeight = GetHeight(neighbor);
        float slope = GetSlope(neighbor, pos);
        
        if (slope > tan_talus)
        {
            float dist = GetDistance(pos, neighbor);
            float targetHeight = neighborHeight + tan_talus * dist;
            totalChange += (targetHeight - height);
            activeCount++;
        }
    }
    
    if (activeCount > 0)
    {
        float avgChange = totalChange / (float) activeCount;
        height += _ThermalDT * avgChange * 0.1;
    }
    
    _TempRT[pos] = height;
}

[numthreads(8, 8, 1)]
void DepositStep(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float height = GetHeight(pos);
    float stream = GetStream(pos);
    float sediment = GetSediment(pos);
    
    float incomingSediment = 0.0;
    for (int i = 0; i < 8; i++)
    {
        int2 q = pos + next8[i];
        if (!IsInBounds(q))
            continue;
        
        float weights[8];
        GetFlowWeights(q, weights);
        int oppositeDir = (i + 4) % 8;
        if (weights[oppositeDir] > 0.0)
        {
            incomingSediment += weights[oppositeDir] * GetSediment(q);
        }
    }
    
    sediment += incomingSediment;
    
    int2 dir = GetSteepestNeighbor(pos);
    int2 receiver = pos + dir;
    float steepestSlope = IsInBounds(receiver) ? GetSlope(receiver, pos) : 0.0;
    
    float speed = clamp(pow(steepestSlope, 2.0), 0.0, 1.0);
    float streamCapacity = pow(stream, 0.3) * speed;
    
    if (_DepositionStrength * sediment > streamCapacity)
    {
        float depositAmount = min(sediment, (_DepositionStrength * sediment - streamCapacity) * 0.1);
        height += depositAmount;
        sediment = max(0.0, sediment - depositAmount);
    }
    
    sediment += 0.1 * streamCapacity;
    
    _OutHeightRT[pos] = height;
    _SedimentRT[pos] = sediment;
}

[numthreads(8, 8, 1)]
void Retargeting(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float height = GetHeight(pos);
    
    float sumHeight = height * 4.0;
    float sumWeights = 4.0;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = pos + next8[i];
        if (IsInBounds(neighbor))
        {
            float weight = (i % 2 == 0) ? 1.0 : 0.7;
            sumHeight += GetHeight(neighbor) * weight;
            sumWeights += weight;
        }
    }
    
    _TempRT[pos] = sumHeight / sumWeights;
}

[numthreads(8, 8, 1)]
void Breaching(uint3 id : SV_DispatchThreadID)
{
    int2 pos = int2(id.xy);
    if (pos.x >= (int) _Width || pos.y >= (int) _Height)
        return;
    
    float height = GetHeight(pos);
    
    bool isPit = true;
    float minNeighborHeight = 1e10;
    
    for (int i = 0; i < 8; i++)
    {
        int2 neighbor = pos + next8[i];
        if (!IsInBounds(neighbor))
            continue;
        
        float neighborHeight = GetHeight(neighbor);
        minNeighborHeight = min(minNeighborHeight, neighborHeight);
        
        if (neighborHeight <= height)
            isPit = false;
    }
    
    if (isPit && minNeighborHeight < 1e10)
    {
        height = minNeighborHeight + 0.001;
    }
    
    _TempRT[pos] = height;
}